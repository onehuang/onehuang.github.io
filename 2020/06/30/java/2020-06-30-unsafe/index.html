<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>unsafe类 | Huangzb's Blog</title><meta name="description" content="unsafe类"><meta name="keywords" content="java,unsafe"><meta name="author" content="Marvin"><meta name="copyright" content="Marvin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://onehuang.github.io/2020/06/30/java/2020-06-30-unsafe/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="unsafe类"><meta name="twitter:description" content="unsafe类"><meta name="twitter:image" content="https://i.loli.net/2019/09/08/6Qze5x3ZvkdRy2B.jpg"><meta property="og:type" content="article"><meta property="og:title" content="unsafe类"><meta property="og:url" content="https://onehuang.github.io/2020/06/30/java/2020-06-30-unsafe/"><meta property="og:site_name" content="Huangzb's Blog"><meta property="og:description" content="unsafe类"><meta property="og:image" content="https://i.loli.net/2019/09/08/6Qze5x3ZvkdRy2B.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title href="https://onehuang.github.io/2020/06/01/java/2020-06-01-树的遍历/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"http://onehuang.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java中的魔法类-Unsafe"><span class="toc-number">1.</span> <span class="toc-text">Java中的魔法类-Unsafe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#内存操作"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">内存操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用堆外内存的原因"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">使用堆外内存的原因#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#典型应用"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">典型应用#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存屏障"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">内存屏障#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统相关"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">系统相关#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程调度"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">线程调度#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象操作"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">对象操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class相关操作"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">class相关操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组-操作"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">数组 操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS操作"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">CAS操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存操作-1"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">内存操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用堆外内存的原因-1"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">使用堆外内存的原因#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#典型应用-1"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">典型应用#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内存屏障-1"><span class="toc-number">1.0.0.14.</span> <span class="toc-text">内存屏障#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#系统相关-1"><span class="toc-number">1.0.0.15.</span> <span class="toc-text">系统相关#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程调度-1"><span class="toc-number">1.0.0.16.</span> <span class="toc-text">线程调度#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象操作-1"><span class="toc-number">1.0.0.17.</span> <span class="toc-text">对象操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class相关操作-1"><span class="toc-number">1.0.0.18.</span> <span class="toc-text">class相关操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组-操作-1"><span class="toc-number">1.0.0.19.</span> <span class="toc-text">数组 操作#</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS操作-1"><span class="toc-number">1.0.0.20.</span> <span class="toc-text">CAS操作#</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/09/08/6Qze5x3ZvkdRy2B.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Huangzb's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">记录生活和工作中的点点滴滴</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/gallery"><i class="fa-fw"></i><span> Gallery</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">unsafe类</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-06-30<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-06-30</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Java中的魔法类-Unsafe"><a href="#Java中的魔法类-Unsafe" class="headerlink" title="Java中的魔法类-Unsafe"></a><a href="https://www.cnblogs.com/rickiyang/p/11334887.html" target="_blank" rel="noopener">Java中的魔法类-Unsafe</a></h1><p>转载： <a href="https://www.cnblogs.com/rickiyang/p/11334887.html" target="_blank" rel="noopener">https://www.cnblogs.com/rickiyang/p/11334887.html</a></p>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p>
<p>但是，这个类的作者不希望我们使用它，因为我们虽然我们获取到了对底层的控制权，但是也增大了风险，安全性正是Java相对于C++/C的优势。因为该类在<code>sun.misc</code>包下，默认是被<strong>BootstrapClassLoader</strong>加载的。如果我们在程序中去调用这个类的话，我们使用的类加载器肯定是 AppClassLoader,问题是在Unsafe中是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class var0 = Reflection.getCallerClass();</span><br><span class="line">  <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将构造函数私有，然后提供了一个静态方法去获取当前类实例。在<code>getUnsafe()</code>方法中首先判断当前类加载器是否为空，因为使用 BootstrapClassLoader 本身就是空，它是用c++实现的，这样就限制了我们在自己的代码中使用这个类。</p>
<p>但是同时作者也算是给我们提供了一个后门，因为Java有反射机制。调用的思路就是将<code>theUnsafe</code>对象设置为可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyField theUnsafeField = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">theUnsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) theUnsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(unsafe);</span><br></pre></td></tr></table></figure>

<p>unsafe类功能介绍：</p>
<p><img src="https://img2018.cnblogs.com/blog/1607781/201908/1607781-20190811141555811-1035387188.png" alt="img"></p>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作#"></a>内存操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2040261920" target="_blank" rel="noopener">#</a></h4><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//分配内存, 相当于C++的malloc函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//扩充内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//在给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset, Object destBase, <span class="keyword">long</span> destOffset, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p>
<h4 id="使用堆外内存的原因"><a href="#使用堆外内存的原因" class="headerlink" title="使用堆外内存的原因#"></a>使用堆外内存的原因<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2477819841" target="_blank" rel="noopener">#</a></h4><ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</li>
<li>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h4 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用#"></a>典型应用<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#4149684064" target="_blank" rel="noopener">#</a></h4><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p>
<p>下面的代码为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CopyDirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">  <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">  <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">  <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">  Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//分配内存，返回基地址</span></span><br><span class="line">    base = unsafe.allocateMemory(size);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">    Bits.unreserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">throw</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//内存初始化</span></span><br><span class="line">  unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Round up to page boundary</span></span><br><span class="line">    address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    address = base;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跟踪directbytebuffer 对象的垃圾回收，实现堆外内存的释放</span></span><br><span class="line">  cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">  att = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最后一句代码通过<code>Cleaner.create()</code>来进行对象监控，释放堆外内存。这里是如何做到的呢？跟踪一下Cleaner类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : add(<span class="keyword">new</span> Cleaner(var0, var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到继承了<code>PhantomReference</code>，Java中的4大引用类型我们都知道。PhantomReference的作用于其他的Refenrence作用大有不同。像 SoftReference、WeakReference都是为了保证引用的类对象能在不用的时候及时的被回收，但是 PhantomReference 并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，对象不可达时就会被垃圾回收器回收，但是任何时候都无法通过虚引用获得对象。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<p>那他的作用到底是啥呢？准确来说 PhantomReference 给使用者提供了一种机制-来监控对象的垃圾回收的活动。</p>
<p>可能这样说不是太明白，我来举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Copypackage com.rickiyang.learn.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhantomReference</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">    System.out.println(str.getClass() + <span class="string">"@"</span> + str.hashCode());</span><br><span class="line">    <span class="keyword">final</span> ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (isRun) &#123;</span><br><span class="line">        Object obj = referenceQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Field rereferent = Reference.class.getDeclaredField(<span class="string">"referent"</span>);</span><br><span class="line">            rereferent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object result = rereferent.get(obj);</span><br><span class="line">            System.out.println(<span class="string">"gc will collect："</span></span><br><span class="line">                               + result.getClass() + <span class="string">"@"</span></span><br><span class="line">                               + result.hashCode() + <span class="string">"\t"</span></span><br><span class="line">                               + result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    PhantomReference&lt;String&gt; weakRef = <span class="keyword">new</span> PhantomReference&lt;&gt;(str, referenceQueue);</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    isRun = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的含义是new PhantomReference()，因为PhantomReference必须的维护一个ReferenceQueue用来保存当前被虚引用的对象。上例中手动去调用<code>referenceQueue.poll()</code>方法，这里你需要注意的是并不是我们主动去释放queue中的对象，你跟踪进去 poll() 方法可以看到有一个全局锁对象，只有当当前对象失去了引用之后才会释放锁，poll()方法才能执行。在执行poll()方法释放对象的时候我们可以针对这个对象做一些监控。这就是 PhantomReference 的意义所在。</p>
<p>说回到 Cleaner， 通过看源码，<code>create()</code>方法调用了<code>add()</code>方法，在Cleaner类里面维护了一个双向链表，将每一个add进来的Cleaner对象都添加到这个链表中维护。那么在Cleaner 链表中的对象实在何时被释放掉呢？</p>
<p>注意到 Cleaner中有一个clean()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">            (<span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.exit(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove()方法是将该对象从内部维护的双向链表中清除。下面紧跟着是<code>thunk.run()</code> ，thunk = 我们通过<code>create()</code>方法传进来的参数，在``DirectByteBuffer中<code>那就是：</code>Cleaner.create(this, new Deallocator(base, size, cap))`,Deallocator类也是一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//省略无关 代码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看到在run方法中调用了<code>freeMemory()</code>去释放掉对象。</p>
<p>在 <code>Reference</code>类中调用了该方法，Reference 类中的静态代码块 有个一内部类：<code>ReferenceHandler</code>,它继承了 Thread，在run方法中调用了 <code>tryHandlePending()</code>，并且被设置为守护线程，意味着会循环不断的处理pending链表中的对象引用。</p>
<p>这里要注意的点是：</p>
<p><strong>Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Copystatic &#123;</span><br><span class="line">  ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">  <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">       tgn != <span class="keyword">null</span>;</span><br><span class="line">       tg = tgn, tgn = tg.getParent());</span><br><span class="line">  Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">  <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">         * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">  handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  handler.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">  SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">  Reference&lt;Object&gt; r;</span><br><span class="line">  Cleaner c;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r = pending;</span><br><span class="line">        <span class="comment">//如果当前Reference对象是Cleaner类型的就进行特殊处理</span></span><br><span class="line">        c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">        pending = r.discovered;</span><br><span class="line">        r.discovered = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">        <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">        <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">          lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry if waited</span></span><br><span class="line">        <span class="keyword">return</span> waitForNotify;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">    <span class="comment">// retry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">    <span class="comment">// retry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clean 不为空的时候，走清理的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">    c.clean();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">  <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryHandlePending</code>这段代码的意思是：</p>
<p>如果一个对象经过JVM检测他已经没有强引用了，但是还有 弱引用 或者 软引用 或者 虚引用的情况下，那么就会把此对象放到一个名为pending的链表里，这个链表是通过Reference.discovered域连接在一起的。</p>
<p><code>ReferenceHandler</code>这个线程会一直从链表中取出被pending的对象，它可能是WeakReference，也可能是SoftReference，当然也可能是PhantomReference和Cleaner。如果是Cleaner，那就直接调用Cleaner的clean方法，然后就结束了。其他的情况下，要交给这个对象所关联的queue，以便于后续的处理。</p>
<p>关于堆外内存分配和回收的代码我们就先分析到这里。需要注意的是对外内存回收的时机也是不确定的，所以不要持续分配一些大对象到堆外，如果没有被回收掉，这是一件很可怕的事情。毕竟它无法被JVM检测到。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障#"></a>内存屏障<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#4108377577" target="_blank" rel="noopener">#</a></h4><p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。内存屏障有两个作用：阻止屏障两侧的指令重排序；强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。在Unsafe中提供了三个方法来操作内存屏障：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//读屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//写屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//全能屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>先简单了解两个指令：</p>
<ul>
<li>Store：将处理器缓存的数据刷新到内存中。</li>
<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>
</ul>
<p>JVM平台提供了一下几种内存屏障：</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)该操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>
<p><strong>loadFence</strong></p>
<p>实现了LoadLoad Barriers，该操作禁止了指令的重排序。</p>
<p><strong>storeFence</strong></p>
<p>实现了 StoreStore Barriers，确保屏障前的写操作能够立刻刷入到主内存，并且确保屏障前的写操作一定先于屏障后的写操作。即保证了内存可见性和禁止指令重排序。</p>
<p><strong>fullFence</strong></p>
<p>实现了 StoreLoad Barriers，强制所有在mfence指令之前的store/load指令，都在该mfence指令执行之前被执行；所有在mfence指令之后的store/load指令，都在该mfence指令执行之后被执行。</p>
<p>在 JDK 中调用了 内存屏障这几个方法的实现类有 <code>StampedLock</code>。关于<code>StampedLock</code>的实现我们后面会专门抽出一篇去讲解。它并没有去实现AQS队列。而是采用了 其他方式实现。</p>
<h4 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关#"></a>系统相关<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3925598916" target="_blank" rel="noopener">#</a></h4><p>这部分包含两个获取系统相关信息的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">addressSize</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="comment">//内存页的大小，此值为2的幂次方。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>java.nio</code>下的Bits类中调用了<code>pagesize()方法计算系统中页大小：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="keyword">int</span> pageSize = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageSize == -<span class="number">1</span>)</span><br><span class="line">        pageSize = unsafe().pageSize();</span><br><span class="line">    <span class="keyword">return</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度#"></a>线程调度<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2884781211" target="_blank" rel="noopener">#</a></h4><p>线程调度中提供的方法包括：线程的挂起，恢复 和 对象锁机制等，其中获取对象的监视器锁方法已经被标记为弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// 终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">// 线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将一个线程进行挂起是通过 park 方法实现的，调用<code>park()</code>后，线程将一直 <strong>阻塞</strong> 直到 <strong>超时</strong> 或者 <strong>中断</strong> 等条件出现。<code>unpark</code>可以释放一个被挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在<code>LockSupport</code>类中，LockSupport 类中有各种版本 pack 方法，但最终都调用了<code>Unsafe.park()</code>方法。 我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypackage leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/8/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread mainThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field theUnsafeField = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        theUnsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) theUnsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPark</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"park %s"</span>, mainThread.getName()));</span><br><span class="line">        unsafe.park(<span class="keyword">false</span>, TimeUnit.SECONDS.toNanos(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s unpark %s"</span>, Thread.currentThread().getName(),</span><br><span class="line">                                             mainThread.getName()));</span><br><span class="line">            unsafe.unpark(mainThread);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">"main thread is done"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">        testUsafe.testPark();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的例子，那你会发现在第29行 <code>park</code>方法设置了超时时间为3秒后，会阻塞当前主线程，直到超时时间到达，下面的代码才会继续执行。</p>
<h4 id="对象操作"><a href="#对象操作" class="headerlink" title="对象操作#"></a>对象操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#751389755" target="_blank" rel="noopener">#</a></h4><p>Unsafe类中提供了多个方法来进行 对象实例化 和 获取对象的偏移地址 的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// 传入一个Class对象并创建该实例对象，但不会调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段f在实例对象中的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值就是f.getDeclaringClass()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">// 静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量；的内存地址，</span></span><br><span class="line"><span class="comment">// 通过偏移量便可得到该对象的变量，进行各种操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象上偏移量的int值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>allocateInstance</code>方法在这几个场景下很有用：跳过对象的实例化阶段（通过构造函数）、忽略构造函数的安全检查（反射newInstance()时）、你需要某类的实例但该类没有public的构造函数。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String address = <span class="string">"beijing"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">"xiaoming"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    System.out.println(user.getname());</span><br><span class="line"></span><br><span class="line">    User user1 = User.class.newInstance();</span><br><span class="line">    System.out.println(user1.getname());</span><br><span class="line"></span><br><span class="line">    User o = (User)unsafe.allocateInstance(User.class);</span><br><span class="line">    System.out.println(o.getname());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果可以看到最后输出的是null，说明构造函数未被加载。可以进一步实验，将User类中的构造函数设置为 private，你会发现在前面两种实例化方式检查期就报错。但是第三种是可以用的。这是因为<code>allocateInstance</code>只是给对象分配了内存，它并不会初始化对象中的属性。</p>
<p>下面是对象操作的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">void</span> <span class="title">testObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过allocateInstance创建对象,为其分配内存地址，不会加载构造函数</span></span><br><span class="line">    User user = (User) unsafe.allocateInstance(User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class &amp;&amp; Field</span></span><br><span class="line">    Class&lt;? extends User&gt; userClass = user.getClass();</span><br><span class="line">    Field name = userClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    Field age = userClass.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">    Field location = userClass.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例域name和age在对象内存中的偏移量并设置值</span></span><br><span class="line">    System.out.println(unsafe.objectFieldOffset(name));</span><br><span class="line">    unsafe.putObject(user, unsafe.objectFieldOffset(name), <span class="string">"xiaoming"</span>);</span><br><span class="line">    System.out.println(unsafe.objectFieldOffset(age));</span><br><span class="line">    unsafe.putInt(user, unsafe.objectFieldOffset(age), <span class="number">18</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取定义location字段的类</span></span><br><span class="line">    Object staticFieldBase = unsafe.staticFieldBase(location);</span><br><span class="line">    System.out.println(staticFieldBase);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取static变量address的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> staticFieldOffset = unsafe.staticFieldOffset(location);</span><br><span class="line">    <span class="comment">// 获取static变量address的值</span></span><br><span class="line">    System.out.println(unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line">    <span class="comment">// 设置static变量address的值</span></span><br><span class="line">    unsafe.putObject(staticFieldBase, staticFieldOffset, <span class="string">"tianjin"</span>);</span><br><span class="line">    System.out.println(user + <span class="string">" "</span> + user.getAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象实例布局与内存大小</strong></p>
<p>一个Java对象占用多大的内存空间呢？这个问题很值得读者朋友去查一下。 因为这个输出本篇的重点所以简单说一下。一个 Java 对象在内存中由对象头、示例数据和对齐填充构成。对象头存储了对象运行时的基本数据，如 hashCode、锁状态、GC 分代年龄、类型指针等等。实例数据是对象中的非静态字段值，可能是一个原始类型的值，也可能是一个指向其他对象的指针。对齐填充就是 padding，保证对象都采用 8 字节对齐。除此以外，在 64 位虚拟机中还可能会开启指针压缩，将 8 字节的指针压缩为 4 字节，这里就不再过多介绍了。</p>
<p>也就是说一个 Java 对象在内存中，首先是对象头，然后是各个类中字段的排列，这之间可能会有 padding 填充。这样我们大概就能理解字段偏移量的含义了，它实际就是每个字段在内存中所处的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field field : User.class.getDeclaredFields()) &#123;</span><br><span class="line">    System.out.println(field.getName() + <span class="string">"-"</span> + field.getType() + <span class="string">": "</span> + unsafe.objectFieldOffset(field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">name-class java.lang.String: 16</span><br><span class="line">age-<span class="keyword">int</span>: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>从上面的运行结果中可以：<br>age：偏移值为12，即前面 12 个字节的对象头；</p>
<p>name：name从16字节开始，因为int 类型的age占了4个字节。</p>
<p>继续算下去整个对象占用的空间，对象头12，age 4，name 是指针类型，开启指针压缩占用4个字节，那么User对象整个占用20字节，因为上面说的padding填充，必须8字节对齐，那么实际上会补上4个字节的填充，即一共占用了24个字节。</p>
<p>按照这种计算方式，我们可以字节写一个计算size的工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line">    HashSet&lt;Field&gt; fields = <span class="keyword">new</span> HashSet&lt;Field&gt;();</span><br><span class="line">    Class c = o.getClass();</span><br><span class="line">    <span class="keyword">while</span> (c != Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                fields.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有继承父类的话，父类中的属性也是要计算的</span></span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个字段的偏移量，因为第一个字段的偏移量即在对象头的基础上偏移的</span></span><br><span class="line">    <span class="comment">//所以只需要比较当前偏移量最大的字段即表示这是该对象最后一个字段的位置</span></span><br><span class="line">    <span class="keyword">long</span> maxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">            maxSize = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面计算的是对象最后一个字段的偏移量起始位置，java中对象最大长度是8个字节(long)</span></span><br><span class="line">    <span class="comment">//这里的计算方式是 将 当前偏移量 / 8 + 8字节 的padding</span></span><br><span class="line">    <span class="keyword">return</span> ((maxSize/<span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的工具类计算的结果也是24。</p>
<h4 id="class相关操作"><a href="#class相关操作" class="headerlink" title="class相关操作#"></a>class相关操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3625206227" target="_blank" rel="noopener">#</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">//获取一个静态字段的对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//确保类被初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//定义一个类，可用于动态创建类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"><span class="comment">//定义一个匿名类，可用于动态创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="keyword">byte</span>[] data, Object[] cpPatches);</span><br></pre></td></tr></table></figure>

<h4 id="数组-操作"><a href="#数组-操作" class="headerlink" title="数组 操作#"></a>数组 操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#1550023992" target="_blank" rel="noopener">#</a></h4><p>数组操作主要有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作#"></a>CAS操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3626613556" target="_blank" rel="noopener">#</a></h4><p>相信所有的开发者对这个词都不陌生，在AQS类中使用了无锁的方式来进行并发控制，主要就是CAS的功劳。</p>
<p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p>
<blockquote>
<p>执行函数：CAS(V,E,N)</p>
</blockquote>
<p>包含3个参数</p>
<ol>
<li>V表示要更新的变量</li>
<li>E表示预期值</li>
<li>N表示新值</li>
</ol>
<p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明没有别的线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。</p>
<p>Unsafe类中提供了三个方法来进行CAS操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,  Object expected, Object update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected,<span class="keyword">int</span> update)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> update)</span></span>;</span><br></pre></td></tr></table></figure>

<p>另外，在 JDK1.8中新增了几个 CAS 的方法，他们的实现是基于上面三个方法做的一层封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Copy <span class="comment">//1.8新增，给定对象o，根据获取内存偏移量指向的字段，将其增加delta，</span></span><br><span class="line"> <span class="comment">//这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//获取内存中最新值</span></span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">       <span class="comment">//通过CAS操作</span></span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8新增，方法作用同上，只不过这里操作的long类型数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.8新增，给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，</span></span><br><span class="line"> <span class="comment">//这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.8新增，同上，操作的是long类型</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.8新增，同上，操作的是引用类型数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object newValue)</span> </span>&#123;</span><br><span class="line">     Object v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getObjectVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。<a href="https://www.cnblogs.com/rickiyang/p/11334887.html" target="_blank" rel="noopener">Java中的魔法类-Unsafe</a></p>
<p>Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。</p>
<p>但是，这个类的作者不希望我们使用它，因为我们虽然我们获取到了对底层的控制权，但是也增大了风险，安全性正是Java相对于C++/C的优势。因为该类在<code>sun.misc</code>包下，默认是被<strong>BootstrapClassLoader</strong>加载的。如果我们在程序中去调用这个类的话，我们使用的类加载器肯定是 AppClassLoader,问题是在Unsafe中是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="keyword">final</span> Unsafe theUnsafe;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Unsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Class var0 = Reflection.getCallerClass();</span><br><span class="line">  <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theUnsafe;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将构造函数私有，然后提供了一个静态方法去获取当前类实例。在<code>getUnsafe()</code>方法中首先判断当前类加载器是否为空，因为使用 BootstrapClassLoader 本身就是空，它是用c++实现的，这样就限制了我们在自己的代码中使用这个类。</p>
<p>但是同时作者也算是给我们提供了一个后门，因为Java有反射机制。调用的思路就是将<code>theUnsafe</code>对象设置为可见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CopyField theUnsafeField = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">theUnsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Unsafe unsafe = (Unsafe) theUnsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(unsafe);</span><br></pre></td></tr></table></figure>

<p>unsafe类功能介绍：</p>
<p><img src="https://img2018.cnblogs.com/blog/1607781/201908/1607781-20190811141555811-1035387188.png" alt="img"></p>
<h4 id="内存操作-1"><a href="#内存操作-1" class="headerlink" title="内存操作#"></a>内存操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2040261920" target="_blank" rel="noopener">#</a></h4><p>这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//分配内存, 相当于C++的malloc函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//扩充内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">reallocateMemory</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//释放内存</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//在给定的内存块中设置值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setMemory</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> bytes, <span class="keyword">byte</span> value)</span></span>;</span><br><span class="line"><span class="comment">//内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">copyMemory</span><span class="params">(Object srcBase, <span class="keyword">long</span> srcOffset, Object destBase, <span class="keyword">long</span> destOffset, <span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"><span class="comment">//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;</span><br><span class="line"><span class="comment">//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">byte</span> <span class="title">getByte</span><span class="params">(<span class="keyword">long</span> address)</span></span>;</span><br><span class="line"><span class="comment">//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putByte</span><span class="params">(<span class="keyword">long</span> address, <span class="keyword">byte</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。</p>
<h4 id="使用堆外内存的原因-1"><a href="#使用堆外内存的原因-1" class="headerlink" title="使用堆外内存的原因#"></a>使用堆外内存的原因<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2477819841" target="_blank" rel="noopener">#</a></h4><ul>
<li>对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</li>
<li>提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</li>
</ul>
<h4 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用#"></a>典型应用<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#4149684064" target="_blank" rel="noopener">#</a></h4><p>DirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。</p>
<p>下面的代码为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">CopyDirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">  <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">  <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">  <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">  Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//分配内存，返回基地址</span></span><br><span class="line">    base = unsafe.allocateMemory(size);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">    Bits.unreserveMemory(size, cap);</span><br><span class="line">    <span class="keyword">throw</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//内存初始化</span></span><br><span class="line">  unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// Round up to page boundary</span></span><br><span class="line">    address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    address = base;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跟踪directbytebuffer 对象的垃圾回收，实现堆外内存的释放</span></span><br><span class="line">  cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">  att = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面最后一句代码通过<code>Cleaner.create()</code>来进行对象监控，释放堆外内存。这里是如何做到的呢？跟踪一下Cleaner类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cleaner <span class="title">create</span><span class="params">(Object var0, Runnable var1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> var1 == <span class="keyword">null</span> ? <span class="keyword">null</span> : add(<span class="keyword">new</span> Cleaner(var0, var1));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到继承了<code>PhantomReference</code>，Java中的4大引用类型我们都知道。PhantomReference的作用于其他的Refenrence作用大有不同。像 SoftReference、WeakReference都是为了保证引用的类对象能在不用的时候及时的被回收，但是 PhantomReference 并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，对象不可达时就会被垃圾回收器回收，但是任何时候都无法通过虚引用获得对象。虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p>
<p>那他的作用到底是啥呢？准确来说 PhantomReference 给使用者提供了一种机制-来监控对象的垃圾回收的活动。</p>
<p>可能这样说不是太明白，我来举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">Copypackage com.rickiyang.learn.javaagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.Reference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-08-08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Desc</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPhantomReference</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> isRun = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br><span class="line">    System.out.println(str.getClass() + <span class="string">"@"</span> + str.hashCode());</span><br><span class="line">    <span class="keyword">final</span> ReferenceQueue&lt;String&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">while</span> (isRun) &#123;</span><br><span class="line">        Object obj = referenceQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Field rereferent = Reference.class.getDeclaredField(<span class="string">"referent"</span>);</span><br><span class="line">            rereferent.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Object result = rereferent.get(obj);</span><br><span class="line">            System.out.println(<span class="string">"gc will collect："</span></span><br><span class="line">                               + result.getClass() + <span class="string">"@"</span></span><br><span class="line">                               + result.hashCode() + <span class="string">"\t"</span></span><br><span class="line">                               + result);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    PhantomReference&lt;String&gt; weakRef = <span class="keyword">new</span> PhantomReference&lt;&gt;(str, referenceQueue);</span><br><span class="line">    str = <span class="keyword">null</span>;</span><br><span class="line">    Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    System.gc();</span><br><span class="line">    Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">    isRun = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码的含义是new PhantomReference()，因为PhantomReference必须的维护一个ReferenceQueue用来保存当前被虚引用的对象。上例中手动去调用<code>referenceQueue.poll()</code>方法，这里你需要注意的是并不是我们主动去释放queue中的对象，你跟踪进去 poll() 方法可以看到有一个全局锁对象，只有当当前对象失去了引用之后才会释放锁，poll()方法才能执行。在执行poll()方法释放对象的时候我们可以针对这个对象做一些监控。这就是 PhantomReference 的意义所在。</p>
<p>说回到 Cleaner， 通过看源码，<code>create()</code>方法调用了<code>add()</code>方法，在Cleaner类里面维护了一个双向链表，将每一个add进来的Cleaner对象都添加到这个链表中维护。那么在Cleaner 链表中的对象实在何时被释放掉呢？</p>
<p>注意到 Cleaner中有一个clean()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (remove(<span class="keyword">this</span>)) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.thunk.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (System.err != <span class="keyword">null</span>) &#123;</span><br><span class="line">            (<span class="keyword">new</span> Error(<span class="string">"Cleaner terminated abnormally"</span>, var2)).printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          System.exit(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>remove()方法是将该对象从内部维护的双向链表中清除。下面紧跟着是<code>thunk.run()</code> ，thunk = 我们通过<code>create()</code>方法传进来的参数，在``DirectByteBuffer中<code>那就是：</code>Cleaner.create(this, new Deallocator(base, size, cap))`,Deallocator类也是一个线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Deallocator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//省略无关 代码</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Paranoia</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.freeMemory(address);</span><br><span class="line">            address = <span class="number">0</span>;</span><br><span class="line">            Bits.unreserveMemory(size, capacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>看到在run方法中调用了<code>freeMemory()</code>去释放掉对象。</p>
<p>在 <code>Reference</code>类中调用了该方法，Reference 类中的静态代码块 有个一内部类：<code>ReferenceHandler</code>,它继承了 Thread，在run方法中调用了 <code>tryHandlePending()</code>，并且被设置为守护线程，意味着会循环不断的处理pending链表中的对象引用。</p>
<p>这里要注意的点是：</p>
<p><strong>Cleaner本身不带有清理逻辑，所有的逻辑都封装在thunk中，因此thunk是怎么实现的才是最关键的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">Copystatic &#123;</span><br><span class="line">  ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">  <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">       tgn != <span class="keyword">null</span>;</span><br><span class="line">       tg = tgn, tgn = tg.getParent());</span><br><span class="line">  Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">  <span class="comment">/* If there were a special system-only priority greater than</span></span><br><span class="line"><span class="comment">         * MAX_PRIORITY, it would be used here</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">  handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">  handler.start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// provide access in SharedSecrets</span></span><br><span class="line">  SharedSecrets.setJavaLangRefAccess(<span class="keyword">new</span> JavaLangRefAccess() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryHandlePendingReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> tryHandlePending(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryHandlePending</span><span class="params">(<span class="keyword">boolean</span> waitForNotify)</span> </span>&#123;</span><br><span class="line">  Reference&lt;Object&gt; r;</span><br><span class="line">  Cleaner c;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pending != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r = pending;</span><br><span class="line">        <span class="comment">//如果当前Reference对象是Cleaner类型的就进行特殊处理</span></span><br><span class="line">        c = r <span class="keyword">instanceof</span> Cleaner ? (Cleaner) r : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// unlink 'r' from 'pending' chain</span></span><br><span class="line">        pending = r.discovered;</span><br><span class="line">        r.discovered = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The waiting on the lock may cause an OutOfMemoryError</span></span><br><span class="line">        <span class="comment">// because it may try to allocate exception objects.</span></span><br><span class="line">        <span class="keyword">if</span> (waitForNotify) &#123;</span><br><span class="line">          lock.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// retry if waited</span></span><br><span class="line">        <span class="keyword">return</span> waitForNotify;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">    <span class="comment">// retry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException x) &#123;</span><br><span class="line">    <span class="comment">// retry</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// clean 不为空的时候，走清理的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">    c.clean();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReferenceQueue&lt;? <span class="keyword">super</span> Object&gt; q = r.queue;</span><br><span class="line">  <span class="keyword">if</span> (q != ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryHandlePending</code>这段代码的意思是：</p>
<p>如果一个对象经过JVM检测他已经没有强引用了，但是还有 弱引用 或者 软引用 或者 虚引用的情况下，那么就会把此对象放到一个名为pending的链表里，这个链表是通过Reference.discovered域连接在一起的。</p>
<p><code>ReferenceHandler</code>这个线程会一直从链表中取出被pending的对象，它可能是WeakReference，也可能是SoftReference，当然也可能是PhantomReference和Cleaner。如果是Cleaner，那就直接调用Cleaner的clean方法，然后就结束了。其他的情况下，要交给这个对象所关联的queue，以便于后续的处理。</p>
<p>关于堆外内存分配和回收的代码我们就先分析到这里。需要注意的是对外内存回收的时机也是不确定的，所以不要持续分配一些大对象到堆外，如果没有被回收掉，这是一件很可怕的事情。毕竟它无法被JVM检测到。</p>
<h4 id="内存屏障-1"><a href="#内存屏障-1" class="headerlink" title="内存屏障#"></a>内存屏障<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#4108377577" target="_blank" rel="noopener">#</a></h4><p>硬件层的内存屏障分为两种：<code>Load Barrier</code> 和 <code>Store Barrier</code>即读屏障和写屏障。内存屏障有两个作用：阻止屏障两侧的指令重排序；强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。在Unsafe中提供了三个方法来操作内存屏障：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//读屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">loadFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//写屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">storeFence</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//全能屏障，禁止load、store操作重排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">fullFence</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>先简单了解两个指令：</p>
<ul>
<li>Store：将处理器缓存的数据刷新到内存中。</li>
<li>Load：将内存存储的数据拷贝到处理器的缓存中。</li>
</ul>
<p>JVM平台提供了一下几种内存屏障：</p>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)该操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>
<p><strong>loadFence</strong></p>
<p>实现了LoadLoad Barriers，该操作禁止了指令的重排序。</p>
<p><strong>storeFence</strong></p>
<p>实现了 StoreStore Barriers，确保屏障前的写操作能够立刻刷入到主内存，并且确保屏障前的写操作一定先于屏障后的写操作。即保证了内存可见性和禁止指令重排序。</p>
<p><strong>fullFence</strong></p>
<p>实现了 StoreLoad Barriers，强制所有在mfence指令之前的store/load指令，都在该mfence指令执行之前被执行；所有在mfence指令之后的store/load指令，都在该mfence指令执行之后被执行。</p>
<p>在 JDK 中调用了 内存屏障这几个方法的实现类有 <code>StampedLock</code>。关于<code>StampedLock</code>的实现我们后面会专门抽出一篇去讲解。它并没有去实现AQS队列。而是采用了 其他方式实现。</p>
<h4 id="系统相关-1"><a href="#系统相关-1" class="headerlink" title="系统相关#"></a>系统相关<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3925598916" target="_blank" rel="noopener">#</a></h4><p>这部分包含两个获取系统相关信息的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">addressSize</span><span class="params">()</span></span>;  </span><br><span class="line"><span class="comment">//内存页的大小，此值为2的幂次方。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 <code>java.nio</code>下的Bits类中调用了<code>pagesize()方法计算系统中页大小：</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Copyprivate <span class="keyword">static</span> <span class="keyword">int</span> pageSize = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">pageSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageSize == -<span class="number">1</span>)</span><br><span class="line">        pageSize = unsafe().pageSize();</span><br><span class="line">    <span class="keyword">return</span> pageSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程调度-1"><a href="#线程调度-1" class="headerlink" title="线程调度#"></a>线程调度<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#2884781211" target="_blank" rel="noopener">#</a></h4><p>线程调度中提供的方法包括：线程的挂起，恢复 和 对象锁机制等，其中获取对象的监视器锁方法已经被标记为弃用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// 终止挂起的线程，恢复正常.java.util.concurrent包中挂起操作都是在LockSupport类实现的，其底层正是使用这两个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Object thread)</span></span>;</span><br><span class="line"><span class="comment">// 线程调用该方法，线程将一直阻塞直到超时，或者是中断条件出现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="comment">//获得对象锁（可重入锁）</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorEnter</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//释放对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">monitorExit</span><span class="params">(Object o)</span></span>;</span><br><span class="line"><span class="comment">//尝试获取对象锁</span></span><br><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">tryMonitorEnter</span><span class="params">(Object o)</span></span>;</span><br></pre></td></tr></table></figure>

<p>将一个线程进行挂起是通过 park 方法实现的，调用<code>park()</code>后，线程将一直 <strong>阻塞</strong> 直到 <strong>超时</strong> 或者 <strong>中断</strong> 等条件出现。<code>unpark</code>可以释放一个被挂起的线程，使其恢复正常。整个并发框架中对线程的挂起操作被封装在<code>LockSupport</code>类中，LockSupport 类中有各种版本 pack 方法，但最终都调用了<code>Unsafe.park()</code>方法。 我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">Copypackage leetcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: rickiyang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2019/8/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Thread mainThread;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field theUnsafeField = Unsafe.class.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">        theUnsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> (Unsafe) theUnsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPark</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Unsafe unsafe = getUnsafe();</span><br><span class="line">        mainThread = Thread.currentThread();</span><br><span class="line"></span><br><span class="line">        System.out.println(String.format(<span class="string">"park %s"</span>, mainThread.getName()));</span><br><span class="line">        unsafe.park(<span class="keyword">false</span>, TimeUnit.SECONDS.toNanos(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%s unpark %s"</span>, Thread.currentThread().getName(),</span><br><span class="line">                                             mainThread.getName()));</span><br><span class="line">            unsafe.unpark(mainThread);</span><br><span class="line">        &#125;).start();</span><br><span class="line">        System.out.println(<span class="string">"main thread is done"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">        testUsafe.testPark();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行上面的例子，那你会发现在第29行 <code>park</code>方法设置了超时时间为3秒后，会阻塞当前主线程，直到超时时间到达，下面的代码才会继续执行。</p>
<h4 id="对象操作-1"><a href="#对象操作-1" class="headerlink" title="对象操作#"></a>对象操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#751389755" target="_blank" rel="noopener">#</a></h4><p>Unsafe类中提供了多个方法来进行 对象实例化 和 获取对象的偏移地址 的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">// 传入一个Class对象并创建该实例对象，但不会调用构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">allocateInstance</span><span class="params">(Class&lt;?&gt; cls)</span> <span class="keyword">throws</span> InstantiationException</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字段f在实例对象中的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">objectFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值就是f.getDeclaringClass()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">// 静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得给定对象偏移量上的int值，所谓的偏移量可以简单理解为指针指向该变量；的内存地址，</span></span><br><span class="line"><span class="comment">// 通过偏移量便可得到该对象的变量，进行各种操作</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象上偏移量的int值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">getObject</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"><span class="comment">// 设置给定对象偏移量上的引用类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object x)</span></span>;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置给定对象的int值，使用volatile语义，即设置后立马更新到内存对其他线程可见</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">// 获得给定对象的指定偏移量offset的int值，使用volatile语义，总能获取到最新的int值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getIntVolatile</span><span class="params">(Object o, <span class="keyword">long</span> offset)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与putIntVolatile一样，但要求被操作字段必须有volatile修饰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">putOrderedInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>allocateInstance</code>方法在这几个场景下很有用：跳过对象的实例化阶段（通过构造函数）、忽略构造函数的安全检查（反射newInstance()时）、你需要某类的实例但该类没有public的构造函数。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String address = <span class="string">"beijing"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">        name = <span class="string">"xiaoming"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例化对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    System.out.println(user.getname());</span><br><span class="line"></span><br><span class="line">    User user1 = User.class.newInstance();</span><br><span class="line">    System.out.println(user1.getname());</span><br><span class="line"></span><br><span class="line">    User o = (User)unsafe.allocateInstance(User.class);</span><br><span class="line">    System.out.println(o.getname());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印的结果可以看到最后输出的是null，说明构造函数未被加载。可以进一步实验，将User类中的构造函数设置为 private，你会发现在前面两种实例化方式检查期就报错。但是第三种是可以用的。这是因为<code>allocateInstance</code>只是给对象分配了内存，它并不会初始化对象中的属性。</p>
<p>下面是对象操作的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">void</span> <span class="title">testObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过allocateInstance创建对象,为其分配内存地址，不会加载构造函数</span></span><br><span class="line">    User user = (User) unsafe.allocateInstance(User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Class &amp;&amp; Field</span></span><br><span class="line">    Class&lt;? extends User&gt; userClass = user.getClass();</span><br><span class="line">    Field name = userClass.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">    Field age = userClass.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">    Field location = userClass.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实例域name和age在对象内存中的偏移量并设置值</span></span><br><span class="line">    System.out.println(unsafe.objectFieldOffset(name));</span><br><span class="line">    unsafe.putObject(user, unsafe.objectFieldOffset(name), <span class="string">"xiaoming"</span>);</span><br><span class="line">    System.out.println(unsafe.objectFieldOffset(age));</span><br><span class="line">    unsafe.putInt(user, unsafe.objectFieldOffset(age), <span class="number">18</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取定义location字段的类</span></span><br><span class="line">    Object staticFieldBase = unsafe.staticFieldBase(location);</span><br><span class="line">    System.out.println(staticFieldBase);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取static变量address的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> staticFieldOffset = unsafe.staticFieldOffset(location);</span><br><span class="line">    <span class="comment">// 获取static变量address的值</span></span><br><span class="line">    System.out.println(unsafe.getObject(staticFieldBase, staticFieldOffset));</span><br><span class="line">    <span class="comment">// 设置static变量address的值</span></span><br><span class="line">    unsafe.putObject(staticFieldBase, staticFieldOffset, <span class="string">"tianjin"</span>);</span><br><span class="line">    System.out.println(user + <span class="string">" "</span> + user.getAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象实例布局与内存大小</strong></p>
<p>一个Java对象占用多大的内存空间呢？这个问题很值得读者朋友去查一下。 因为这个输出本篇的重点所以简单说一下。一个 Java 对象在内存中由对象头、示例数据和对齐填充构成。对象头存储了对象运行时的基本数据，如 hashCode、锁状态、GC 分代年龄、类型指针等等。实例数据是对象中的非静态字段值，可能是一个原始类型的值，也可能是一个指向其他对象的指针。对齐填充就是 padding，保证对象都采用 8 字节对齐。除此以外，在 64 位虚拟机中还可能会开启指针压缩，将 8 字节的指针压缩为 4 字节，这里就不再过多介绍了。</p>
<p>也就是说一个 Java 对象在内存中，首先是对象头，然后是各个类中字段的排列，这之间可能会有 padding 填充。这样我们大概就能理解字段偏移量的含义了，它实际就是每个字段在内存中所处的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Copypublic <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field field : User.class.getDeclaredFields()) &#123;</span><br><span class="line">    System.out.println(field.getName() + <span class="string">"-"</span> + field.getType() + <span class="string">": "</span> + unsafe.objectFieldOffset(field));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">name-class java.lang.String: 16</span><br><span class="line">age-<span class="keyword">int</span>: <span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>从上面的运行结果中可以：<br>age：偏移值为12，即前面 12 个字节的对象头；</p>
<p>name：name从16字节开始，因为int 类型的age占了4个字节。</p>
<p>继续算下去整个对象占用的空间，对象头12，age 4，name 是指针类型，开启指针压缩占用4个字节，那么User对象整个占用20字节，因为上面说的padding填充，必须8字节对齐，那么实际上会补上4个字节的填充，即一共占用了24个字节。</p>
<p>按照这种计算方式，我们可以字节写一个计算size的工具类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sizeOf</span><span class="params">(Object o)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    TestUsafe testUsafe = <span class="keyword">new</span> TestUsafe();</span><br><span class="line">    Unsafe unsafe = testUsafe.getUnsafe();</span><br><span class="line">    HashSet&lt;Field&gt; fields = <span class="keyword">new</span> HashSet&lt;Field&gt;();</span><br><span class="line">    Class c = o.getClass();</span><br><span class="line">    <span class="keyword">while</span> (c != Object.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field f : c.getDeclaredFields()) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((f.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                fields.add(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有继承父类的话，父类中的属性也是要计算的</span></span><br><span class="line">        c = c.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算每个字段的偏移量，因为第一个字段的偏移量即在对象头的基础上偏移的</span></span><br><span class="line">    <span class="comment">//所以只需要比较当前偏移量最大的字段即表示这是该对象最后一个字段的位置</span></span><br><span class="line">    <span class="keyword">long</span> maxSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">        <span class="keyword">long</span> offset = unsafe.objectFieldOffset(f);</span><br><span class="line">        <span class="keyword">if</span> (offset &gt; maxSize) &#123;</span><br><span class="line">            maxSize = offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面计算的是对象最后一个字段的偏移量起始位置，java中对象最大长度是8个字节(long)</span></span><br><span class="line">    <span class="comment">//这里的计算方式是 将 当前偏移量 / 8 + 8字节 的padding</span></span><br><span class="line">    <span class="keyword">return</span> ((maxSize/<span class="number">8</span>) + <span class="number">1</span>) * <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的工具类计算的结果也是24。</p>
<h4 id="class相关操作-1"><a href="#class相关操作-1" class="headerlink" title="class相关操作#"></a>class相关操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3625206227" target="_blank" rel="noopener">#</a></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//静态属性的偏移量，用于在对应的Class对象中读写静态属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">staticFieldOffset</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">//获取一个静态字段的对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Object <span class="title">staticFieldBase</span><span class="params">(Field f)</span></span>;</span><br><span class="line"><span class="comment">//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">shouldBeInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//确保类被初始化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">ensureClassInitialized</span><span class="params">(Class&lt;?&gt; c)</span></span>;</span><br><span class="line"><span class="comment">//定义一个类，可用于动态创建类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len,</span><br><span class="line">                                   ClassLoader loader,</span><br><span class="line">                                   ProtectionDomain protectionDomain);</span><br><span class="line"><span class="comment">//定义一个匿名类，可用于动态创建类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, <span class="keyword">byte</span>[] data, Object[] cpPatches);</span><br></pre></td></tr></table></figure>

<h4 id="数组-操作-1"><a href="#数组-操作-1" class="headerlink" title="数组 操作#"></a>数组 操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#1550023992" target="_blank" rel="noopener">#</a></h4><p>数组操作主要有两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copy<span class="comment">//返回数组中第一个元素的偏移地址</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayBaseOffset</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br><span class="line"><span class="comment">//返回数组中一个元素占用的大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">arrayIndexScale</span><span class="params">(Class&lt;?&gt; arrayClass)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="CAS操作-1"><a href="#CAS操作-1" class="headerlink" title="CAS操作#"></a>CAS操作<a href="https://www.cnblogs.com/rickiyang/p/11334887.html#3626613556" target="_blank" rel="noopener">#</a></h4><p>相信所有的开发者对这个词都不陌生，在AQS类中使用了无锁的方式来进行并发控制，主要就是CAS的功劳。</p>
<p>CAS的全称是Compare And Swap 即比较交换，其算法核心思想如下</p>
<blockquote>
<p>执行函数：CAS(V,E,N)</p>
</blockquote>
<p>包含3个参数</p>
<ol>
<li>V表示要更新的变量</li>
<li>E表示预期值</li>
<li>N表示新值</li>
</ol>
<p>如果V值等于E值，则将V的值设为N。若V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。通俗的理解就是CAS操作需要我们提供一个期望值，当期望值与当前线程的变量值相同时，说明没有别的线程修改该值，当前线程可以进行修改，也就是执行CAS操作，但如果期望值与当前线程不符，则说明该值已被其他线程修改，此时不执行更新操作，但可以选择重新读取该变量再尝试再次修改该变量，也可以放弃操作。</p>
<p>Unsafe类中提供了三个方法来进行CAS操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Copypublic <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object o, <span class="keyword">long</span> offset,  Object expected, Object update)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> expected,<span class="keyword">int</span> update)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> expected, <span class="keyword">long</span> update)</span></span>;</span><br></pre></td></tr></table></figure>

<p>另外，在 JDK1.8中新增了几个 CAS 的方法，他们的实现是基于上面三个方法做的一层封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Copy <span class="comment">//1.8新增，给定对象o，根据获取内存偏移量指向的字段，将其增加delta，</span></span><br><span class="line"> <span class="comment">//这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         <span class="comment">//获取内存中最新值</span></span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">       <span class="comment">//通过CAS操作</span></span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.8新增，方法作用同上，只不过这里操作的long类型数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, v + delta));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.8新增，给定对象o，根据获取内存偏移量对于字段，将其 设置为新值newValue，</span></span><br><span class="line"> <span class="comment">//这是一个CAS操作过程，直到设置成功方能退出循环，返回旧值</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getIntVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.8新增，同上，操作的是long类型</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">long</span> newValue)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">long</span> v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getLongVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapLong(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.8新增，同上，操作的是引用类型数据</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">getAndSetObject</span><span class="params">(Object o, <span class="keyword">long</span> offset, Object newValue)</span> </span>&#123;</span><br><span class="line">     Object v;</span><br><span class="line">     <span class="keyword">do</span> &#123;</span><br><span class="line">         v = getObjectVolatile(o, offset);</span><br><span class="line">     &#125; <span class="keyword">while</span> (!compareAndSwapObject(o, offset, v, newValue));</span><br><span class="line">     <span class="keyword">return</span> v;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>CAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Marvin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://onehuang.github.io/2020/06/30/java/2020-06-30-unsafe/">https://onehuang.github.io/2020/06/30/java/2020-06-30-unsafe/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java    </a><a class="post-meta__tags" href="/tags/unsafe/">unsafe    </a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/09/08/6Qze5x3ZvkdRy2B.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> Donate<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" data-src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/06/01/java/2020-06-01-树的遍历/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span></span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/18/2019-09-08-Arthas总结/" title="2019-09-08-Arthas总结"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/08/ner6kBiGuMjpQm3.png"><div class="relatedPosts_title">2019-09-08-Arthas总结</div></a></div><div class="relatedPosts_item"><a href="/2019/09/18/2019-09-18-idea插件总结/" title="idea插件总结"><img class="relatedPosts_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">idea插件总结</div></a></div><div class="relatedPosts_item"><a href="/2019/07/31/java/2019-07-31-java函数式接口编程/" title="java函数式接口编程"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/08/6Qze5x3ZvkdRy2B.jpg"><div class="relatedPosts_title">java函数式接口编程</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2020 By Marvin</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">繁</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script></body></html>